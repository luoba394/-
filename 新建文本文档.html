<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>复古贪吃蛇 (Retro Snake)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #1a1a1a;
            margin: 0;
            overflow: hidden;
            touch-action: none;
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }

        /* CRT 扫描线特效 */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(
                to bottom,
                rgba(18, 16, 16, 0) 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            z-index: 50;
        }

        .scanlines::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            animation: flicker 0.15s infinite;
            pointer-events: none;
        }

        @keyframes flicker {
            0% { opacity: 0.02; }
            50% { opacity: 0.05; }
            100% { opacity: 0.02; }
        }

        /* 游戏容器辉光 */
        .game-container {
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.2);
        }

        /* 按钮样式 */
        .d-pad-btn {
            background-color: #374151;
            border: 2px solid #4B5563;
            box-shadow: 0 4px 0 0 rgba(0,0,0,0.5);
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .d-pad-btn:active {
            transform: translateY(4px);
            box-shadow: none;
            background-color: #4B5563;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
  }
}
</script>
</head>
<body class="bg-neutral-900 text-green-400 flex flex-col items-center justify-center min-h-screen select-none">

    <!-- CRT 覆盖层 -->
    <div class="scanlines"></div>

    <!-- 背景装饰 -->
    <div class="fixed inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-green-900/20 via-black to-black pointer-events-none"></div>

    <!-- 顶部 UI -->
    <div class="z-10 w-full max-w-[500px] px-4 mb-2 flex justify-between items-end">
        <div>
            <h1 class="text-2xl font-bold text-green-500 tracking-wider drop-shadow-[0_0_5px_rgba(74,222,128,0.5)]">贪吃蛇</h1>
            <p class="text-[10px] text-green-700 mt-1">RETRO SNAKE</p>
        </div>
        <div class="text-right">
            <div class="text-yellow-500 text-[10px] mb-1">最高分: <span id="highScoreVal">0</span></div>
            <div class="text-2xl font-bold leading-none" id="scoreVal">0000</div>
        </div>
    </div>

    <!-- 游戏画布区域 -->
    <div class="relative z-10 game-container bg-gray-900 border-4 border-gray-700 rounded-lg p-1">
        <canvas id="gameCanvas" width="400" height="400" class="bg-gray-800/50 block rounded-sm cursor-pointer"></canvas>
        
        <!-- 开始/暂停/结束 覆盖层 -->
        <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 backdrop-blur-sm z-20 rounded transition-opacity duration-300">
            <h2 id="overlayTitle" class="text-3xl mb-4 text-white animate-pulse font-bold">准备开始</h2>
            <p id="overlaySubtitle" class="text-xs text-gray-400 mb-6">点击屏幕或按空格键</p>
            <button id="actionBtn" class="px-6 py-3 bg-green-600 hover:bg-green-500 text-black font-bold rounded shadow-[0_4px_0_0_rgba(0,0,0,0.5)] active:translate-y-1 active:shadow-none transition-all">
                开始游戏
            </button>
        </div>
    </div>

    <!-- 虚拟按键 (仅移动端可见，或者屏幕较小时) -->
    <div class="z-10 mt-6 grid grid-cols-3 gap-2 md:hidden">
        <div></div>
        <button class="d-pad-btn w-14 h-14 rounded-lg" ontouchstart="handleTouchBtn('UP')" onmousedown="handleTouchBtn('UP')">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4ade80" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="m18 15-6-6-6 6"/></svg>
        </button>
        <div></div>
        
        <button class="d-pad-btn w-14 h-14 rounded-lg" ontouchstart="handleTouchBtn('LEFT')" onmousedown="handleTouchBtn('LEFT')">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4ade80" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
        </button>
        <button class="d-pad-btn w-14 h-14 rounded-lg" ontouchstart="handleTouchBtn('DOWN')" onmousedown="handleTouchBtn('DOWN')">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4ade80" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <button class="d-pad-btn w-14 h-14 rounded-lg" ontouchstart="handleTouchBtn('RIGHT')" onmousedown="handleTouchBtn('RIGHT')">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4ade80" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
        </button>
    </div>

    <!-- 桌面端提示 -->
    <div class="hidden md:block mt-4 z-10 text-center text-green-800 text-xs">
        <p>[↑↓←→] 或 [WASD] 移动 • [空格] 暂停/继续</p>
    </div>

    <script>
        // --- 常量配置 ---
        const GRID_SIZE = 20;
        const TILE_COUNT = 20; // 20x20 网格
        const INITIAL_SPEED = 150;
        const MIN_SPEED = 50;
        const COLORS = {
            background: '#1f2937', // gray-800
            snakeHead: '#4ade80',  // green-400
            snakeBody: '#16a34a',  // green-600
            food: '#ef4444',       // red-500
            gridLine: '#374151'    // gray-700
        };

        // --- 游戏状态 ---
        let canvas, ctx;
        let gameInterval;
        let snake = [];
        let food = { x: 10, y: 10 };
        let direction = { x: 0, y: -1 }; // 默认向上
        let nextDirectionQueue = []; // 输入缓冲队列，防止按键冲突
        let score = 0;
        let highScore = localStorage.getItem('retro-snake-highscore') || 0;
        let speed = INITIAL_SPEED;
        let status = 'IDLE'; // IDLE, PLAYING, PAUSED, GAMEOVER

        // --- 初始化 ---
        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // 响应式画布大小
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // 绑定事件
            document.addEventListener('keydown', handleKeyDown);
            document.getElementById('actionBtn').addEventListener('click', handleAction);
            document.getElementById('overlay').addEventListener('click', () => {
                if (status === 'IDLE' || status === 'GAMEOVER') startGame();
                else if (status === 'PAUSED') resumeGame();
            });

            // 阻止空格键滚动
            window.addEventListener('keydown', function(e) {
                if(e.code === 'Space') e.preventDefault();
            });

            // 更新最高分显示
            document.getElementById('highScoreVal').innerText = highScore;
            
            // 初始绘制
            draw();
        };

        function resizeCanvas() {
            // 保持正方形，最大宽度为视口宽度的90%或500px
            const maxSize = Math.min(window.innerWidth * 0.9, 500);
            // 确保是 GRID_SIZE 的倍数，防止模糊
            const size = Math.floor(maxSize / TILE_COUNT) * TILE_COUNT;
            
            canvas.style.width = `${size}px`;
            canvas.style.height = `${size}px`;
            // 内部分辨率保持固定，CSS控制显示大小，或者同步调整内部分辨率
            // 这里为了清晰度，我们让 internal resolution = display size
            canvas.width = size;
            canvas.height = size;
            
            if (status !== 'PLAYING') draw();
        }

        // --- 游戏核心逻辑 ---

        function startGame() {
            snake = [
                { x: 10, y: 10 },
                { x: 10, y: 11 },
                { x: 10, y: 12 }
            ];
            direction = { x: 0, y: -1 };
            nextDirectionQueue = [];
            score = 0;
            speed = INITIAL_SPEED;
            status = 'PLAYING';
            placeFood();
            
            updateScoreUI();
            hideOverlay();
            
            if (gameInterval) clearTimeout(gameInterval);
            gameLoop();
        }

        function gameLoop() {
            if (status !== 'PLAYING') return;

            update();
            draw();

            gameInterval = setTimeout(gameLoop, speed);
        }

        function update() {
            // 处理输入队列
            if (nextDirectionQueue.length > 0) {
                const nextDir = nextDirectionQueue.shift();
                // 防止掉头
                if (nextDir.x !== -direction.x || nextDir.y !== -direction.y) {
                    direction = nextDir;
                }
            }

            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            // 撞墙检测
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                gameOver();
                return;
            }

            // 撞自己检测
            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head); // 加头

            // 吃食物
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                if (speed > MIN_SPEED) speed -= 2;
                updateScoreUI();
                placeFood();
                // 不移除尾巴，蛇变长
            } else {
                snake.pop(); // 移除尾巴，移动
            }
        }

        function draw() {
            const tileSize = canvas.width / TILE_COUNT;

            // 清空背景
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 画网格 (可选，增加复古感)
            ctx.strokeStyle = 'rgba(55, 65, 81, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i <= TILE_COUNT; i++) {
                ctx.moveTo(i * tileSize, 0);
                ctx.lineTo(i * tileSize, canvas.height);
                ctx.moveTo(0, i * tileSize);
                ctx.lineTo(canvas.width, i * tileSize);
            }
            ctx.stroke();

            // 画食物
            const foodX = food.x * tileSize;
            const foodY = food.y * tileSize;
            const foodPad = 2;
            
            ctx.fillStyle = COLORS.food;
            // 简单的发光效果
            ctx.shadowColor = COLORS.food;
            ctx.shadowBlur = 10;
            ctx.fillRect(foodX + foodPad, foodY + foodPad, tileSize - foodPad*2, tileSize - foodPad*2);
            ctx.shadowBlur = 0;

            // 画蛇
            snake.forEach((segment, index) => {
                const x = segment.x * tileSize;
                const y = segment.y * tileSize;
                const pad = 1;

                if (index === 0) {
                    // 头
                    ctx.fillStyle = COLORS.snakeHead;
                    ctx.shadowColor = COLORS.snakeHead;
                    ctx.shadowBlur = 10;
                    ctx.fillRect(x + pad, y + pad, tileSize - pad*2, tileSize - pad*2);
                    ctx.shadowBlur = 0;
                    
                    // 眼睛 (简单装饰)
                    ctx.fillStyle = '#000';
                    const eyeSize = tileSize / 5;
                    if (direction.x === 1) { // Right
                        ctx.fillRect(x + tileSize - 8, y + 5, eyeSize, eyeSize);
                        ctx.fillRect(x + tileSize - 8, y + tileSize - 8, eyeSize, eyeSize);
                    } else if (direction.x === -1) { // Left
                        ctx.fillRect(x + 5, y + 5, eyeSize, eyeSize);
                        ctx.fillRect(x + 5, y + tileSize - 8, eyeSize, eyeSize);
                    } else if (direction.y === -1) { // Up
                        ctx.fillRect(x + 5, y + 5, eyeSize, eyeSize);
                        ctx.fillRect(x + tileSize - 8, y + 5, eyeSize, eyeSize);
                    } else { // Down
                        ctx.fillRect(x + 5, y + tileSize - 8, eyeSize, eyeSize);
                        ctx.fillRect(x + tileSize - 8, y + tileSize - 8, eyeSize, eyeSize);
                    }

                } else {
                    // 身体
                    ctx.fillStyle = COLORS.snakeBody;
                    ctx.fillRect(x + pad, y + pad, tileSize - pad*2, tileSize - pad*2);
                }
            });
        }

        function placeFood() {
            let valid = false;
            while (!valid) {
                food = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
                // 确保不生成在蛇身上
                valid = !snake.some(segment => segment.x === food.x && segment.y === food.y);
            }
        }

        function gameOver() {
            status = 'GAMEOVER';
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('retro-snake-highscore', highScore);
            }
            showOverlay('游戏结束', `最终得分: ${score}`, '再来一局');
        }

        function togglePause() {
            if (status === 'PLAYING') {
                status = 'PAUSED';
                clearTimeout(gameInterval);
                showOverlay('已暂停', '点击继续', '继续游戏');
            } else if (status === 'PAUSED') {
                resumeGame();
            }
        }

        function resumeGame() {
            status = 'PLAYING';
            hideOverlay();
            gameLoop();
        }

        // --- UI 控制 ---

        function updateScoreUI() {
            document.getElementById('scoreVal').innerText = score.toString().padStart(4, '0');
            document.getElementById('highScoreVal').innerText = highScore;
        }

        function showOverlay(title, subtitle, btnText) {
            const el = document.getElementById('overlay');
            document.getElementById('overlayTitle').innerText = title;
            document.getElementById('overlaySubtitle').innerText = subtitle;
            document.getElementById('actionBtn').innerText = btnText;
            document.getElementById('overlayTitle').className = status === 'GAMEOVER' ? "text-3xl mb-4 text-red-500 font-bold" : "text-3xl mb-4 text-white animate-pulse font-bold";
            
            el.classList.remove('opacity-0', 'pointer-events-none');
        }

        function hideOverlay() {
            const el = document.getElementById('overlay');
            el.classList.add('opacity-0', 'pointer-events-none');
        }

        function handleAction(e) {
            e.stopPropagation(); // 防止冒泡触发 overlay 的点击
            if (status === 'IDLE' || status === 'GAMEOVER') startGame();
            else if (status === 'PAUSED') resumeGame();
        }

        // --- 输入控制 ---

        function handleKeyDown(e) {
            if (e.code === 'Space') {
                if (status === 'IDLE' || status === 'GAMEOVER') startGame();
                else togglePause();
                return;
            }
            
            // 只有游戏进行中才处理方向
            if (status !== 'PLAYING') return;

            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    queueDirection(0, -1); break;
                case 'ArrowDown': case 's': case 'S':
                    queueDirection(0, 1); break;
                case 'ArrowLeft': case 'a': case 'A':
                    queueDirection(-1, 0); break;
                case 'ArrowRight': case 'd': case 'D':
                    queueDirection(1, 0); break;
            }
        }

        function handleTouchBtn(dir) {
            if (status !== 'PLAYING') {
                 // 如果还没开始，按方向键也可以开始
                 if (status === 'IDLE') startGame();
                 return;
            }
            
            switch(dir) {
                case 'UP': queueDirection(0, -1); break;
                case 'DOWN': queueDirection(0, 1); break;
                case 'LEFT': queueDirection(-1, 0); break;
                case 'RIGHT': queueDirection(1, 0); break;
            }
        }

        function queueDirection(x, y) {
            // 获取当前所有计划中的最后一步方向
            // 如果队列为空，则基于当前实际方向
            const lastPlan = nextDirectionQueue.length > 0 
                ? nextDirectionQueue[nextDirectionQueue.length - 1] 
                : direction;

            // 检查是否反向 (例如: 当前向上，不能立刻向下)
            if (x !== -lastPlan.x || y !== -lastPlan.y) {
                // 避免重复添加同一方向
                if (x !== lastPlan.x || y !== lastPlan.y) {
                    // 限制队列长度，防止积压太多操作
                    if (nextDirectionQueue.length < 3) {
                        nextDirectionQueue.push({x, y});
                    }
                }
            }
        }
    </script>
</body>
</html>